<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git操作命令总结]]></title>
    <url>%2F2018%2F04%2F02%2Fgit%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HEAD：当前commit引用 $ git version # → git版本 $ git branch # → 查看本地所有的分支 $ git branch # → 查看本地所有的分支$ git branch -r # → 查看所有远程的分支 $ git branch -a # → 查看所有远程分支和本地分支 $ git branch -d # → 删除本地branchname分支 $ git branch -m brancholdname branchnewname # → 重命名分支 $ git branch # → 创建branchname分支 $ git checkout # → 切换分支到branchname $ git checkout -b # → 等同于执行上两步，即创建新的分支并切换到该分支 $ git checkout – xx/xx # → 回滚单个文件 $ git pull origin master:master # → 将远程origin主机的master分支合并到当前master分支,冒号后面的部分表示当前本地所在的分支 $ git push origin -d # → 删除远程branchname分支 $ git fetch –p # → 更新分支 $ git status # → 查看仓库状态 $ git add xx # → 把xx文件添加到暂存区去 $ git commit -m ‘ ‘ # → 提交文件 -m 后面的是注释(不建议使用?) $ git commit -am(-a -m) # → 提交所有的修改，等同于上两步(不建议使用?) $ git commit ./xx # → 等同于git add ./xx + git commit（建议使用?） $ git commit –amend # → 将暂存区和当前commit合并创建一个新commit去替换当前commit $ git stash # → 把当前的工作隐藏起来 等以后恢复现场后继续工作 $ git stash pop # → 恢复工作现场（恢复隐藏的文件，同时删除stash列表中对应的内容） $ git fetch –all # → 将远程主机的更新全部取回本地 $ git merge origin/master # → 在本地（当前）分支上合并远程分支 $ git merge –abort # → 终止本次merge，并回到merge前的状态（?） $ git pull origin master # → 从远程获取最新版本并merge到本地等同于 $ git fetch origin master + $ git merge origin/master（前者更安全一些） $ git push origin master # → 将本地master分支推送到远程origin主机的master分支 $ git log xx # → 查看xx文件的commit记录 $ git log -p xx # → 查看xx文件每次提交的diff $ git log –pretty=oneline xx # → 查看xx文件提交的历史记录（只显示哈希值和提交说明） $ git log –pretty=raw # → 查看commit之间的父子关系（root commit是没有父提交的） $ git log –graph # → 查看当前分支commit生成的树状图 $ git diff HEAD HEAD^1 – xx # → 查看xx文件不同版本之间的差异 $ git diff HEAD~1 # → 显示父节点的提交 git中‘~’和‘^’的区别： (|HEAD)^n，指的是HEAD的第n个父提交，可以通过在“^”后面跟上一个数字，表示第几个父提交，“^”相当“^1”。例如：HEAD^2 表示HEAD的第二次父提交。(|HEAD)~n，指的是HEAD的第n个祖先提交，可以通过在“~”后面跟上一个数字，表示第几个祖父提交，“~”相当“~1”，“~n”相当于连续的个“^”。例如：HEAD~2 表示HEAD的第一个父提交的第一个父提交。 等式1：HEAD~ === HEAD^ === HEAD^1 等式2：HEAD~2 === HEAD^^ === HEAD^1^1 $ git diff –staged/–cached # → 显示暂存区和上一次提交的不同，git add之前忘diff的后悔药 $ git show –stat # → 查看最后一次的修改 $ git show HEAD # → 查看指定版本的修改（可省略HEAD，默认当前版本） 同上 $ git show HEAD xxx # → 查看指定版本xx文件的修改（可省略HEAD，默认当前版本） $ git reset –hard HEAD # → 回滚到指定版本，同时清空工作目录的所有改动 $ git reset –soft HEAD # → 回滚到指定版本，同时保留工作目录和暂存区的内容，并把重置的位置所导致的新的文件差异放进暂存区 $ git reset –mixed HEAD # → （默认）回滚到指定版本，同时保留工作目录的内容，并清空暂存区 $ git reset –hard origin/master # → 将本地master与远程master同步 –hard –soft –mixed的区别可用下图表示： 假设当前commit和工作目录如下所示：如果这时你执行：git reset –hard HEAD^改动全部消失，未跟踪文件除外⬆️ git show –stat查看此时对应的当前commit⬆️2⃣️如果这时你执行：git reset –soft HEAD^reset之前commit的改动被放进暂存区，并保留了工作目录⬆️ git show –stat查看此时对应的当前commit⬆️如果这时你执行：git reset –mixed HEAD^同–soft一样保留了工作目录，但暂存区被全部被清空，之前commit的改动被放到未追踪文件中⬆️ git show –stat查看此时对应的当前commit⬆️$ git reflog show –date=iso # → 查看分支的创建时间 $ git branch -r | awk ‘{print $1}’ | egrep -v -f /dev/fd/0 &lt;(git branch -vv | grep origin) | awk ‘{print $1}’ | xargs git branch -d # → 删除在远程已被删除的本地分支 (慎用) $ git remote show origin # → 查看remote地址，远程分支，还有本地分支与之相对应关系等信息。 $ git remote prune origin # → 删除了那些远程仓库不存在的分支 === git fetch -p $ git config # → 查看和编辑git的配置查看格式：git config [–local|–global|–system] -l $ git config –local -l # → 查看仓库级的config $ git config –global -l # → 查看全局级的config 编辑格式：git config [–local|–global|–system] -e $ git config –local -e # → 编辑仓库级的config $ git config –global -e # → 编辑全局级的config 修改格式：git config [–local|–global|–system] section.key value $ git config –local push.default ‘simple’ # → 修改仓库级的push.default的默认行为 $ git config –global push.default ‘current’ # → 修改全局级的push.default的默认行为 关于git default配置这里 增加格式:git config [–local|–global|–system] –add section.key value(默认是添加在local配置中) $ git config –add cat.name songhw # → local配置写入 cat.name = songhw $ git config –local –add cat.name songhw # → 等同于上一步 $ git config –global –add cat.name lhammer # → global配置写入 cat.name = lhammer 获取格式：git config [–local|–global|–system] –get section.key(默认是获取local配置中内容) $ git config –get cat.name # → 输出songhw $ git config –local –get cat.name # → 输出结果同上一步 $ git config –global –get cat.name # → 输出lhammer 删除格式：git config [–local|–global|–system] –unset section.key $ git config –local –unset cat.name # → 删除local配置中的cat.name = songhw $ git config –global –unset cat.name # → 删除local配置中的cat.name = lhammer $ git rebase master # → 在当前分支对master执行rebase $ git rebase -i 目标commit # → 修改历史某一次提交 把需要修改的commit对应的操作指令从pick改为edit $ gitrebase –continue # → 接上一步修改完之后，继续rebase $ gitrebase –onto HEAD HEAD^1 # → 撤销指定的commit，即消失在历史中 $ git push origin -f # → 忽略冲突，强制提交 $ git revert HEAD # → 撤销指定的commit（?） git revert和git rebase –onto的区别： git revert会增加一条新的commit，它的内容与指定commit的修改是相反的，两次相互抵消从而达到撤销的效果，并且在commit历史中，会存在两条提交，一条原始commit，一条它的反转commit，而git rebase –onto是直接将commit从历史记录中直接删除。 $ git checkout HEAD(c08de9a) # → c08de9a为brance删除之前所在的位置 $ git checkout -b # → 重新创建，找回删除的分支 注：不再被引用直接或间接指向的commit会在一定的时间被git回收，所以通过reflog操作找回删除的分支一定要及时，不然有可能由于commit被回收导致永远也找不回了$ git tag # → 列出所有tag $ git tag -l version1.* # → 只会列出1.几的版本 $ git tag (version 1.0) # → 创建轻量级的tag $ git tag -a (version1.0) -m ‘first version’ # → 创建带有信息的tag $ git tag -d (version 1.0) # → 删除指定tag $ git checkout (version 1.0) # → 检出指定tag 作者：LHammer链接：https://juejin.im/post/5a2cdfe26fb9a0452936b07f来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>-github</category>
      </categories>
      <tags>
        <tag>-前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何处理嵌套的表格边框]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%A1%A8%E6%A0%BC%E5%B5%8C%E5%A5%97%E8%BE%B9%E6%A1%86%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[外层table与内层table嵌套，内外表格都需边框时，设置“border=1”，但边框会重复，造成某些地方边框粗，有些地方边框细的问题。解决办法：外表格样式：1&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;border-collapse: collapse;”&gt; 内表格样式：1&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;border-collapse: collapse;border-width:0px; border-style:hidden;&quot;&gt; 按照如上设置：嵌套表格看起来就像一个表格一样，非常漂亮！原文地址]]></content>
      <categories>
        <category>-css样式</category>
      </categories>
      <tags>
        <tag>-web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则验证手机号，邮箱]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%AD%A3%E5%88%99%E9%AA%8C%E8%AF%81%E6%89%8B%E6%9C%BA%E5%8F%B7%E5%92%8C%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[手机号验证1^1[3|4|5|7|8][0-9]&#123;9&#125;$ 这是精准的手机号验证格式解释 ：开头数字是1，第二位数字，是3到8的任何一个数字，后面是0到9的任意数字，一共9个字符 邮箱验证1/^[a-z0-9!#$%&amp;&apos;*+\/=?^_`&#123;|&#125;~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i 验证手机号或者邮箱 1/（^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$）|（^[a-z0-9!#$%&amp;&apos;*+\/=?^_`&#123;|&#125;~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$）/i 正则表达式的两种定义方式： 123var reg = /^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$/;var reg = new RegExp(&apos;^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$&apos;);reg.test(&apos;123@qq.com&apos;)]]></content>
      <categories>
        <category>-javascipt</category>
      </categories>
      <tags>
        <tag>-web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载控件（点击链接下载文件）]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%B8%8B%E8%BD%BD%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[html部分1&lt;a href=&quot;download.php?file=这里写你需要下载的文件地址&quot;&gt;UCdownload&lt;/a&gt; php部分12345678&lt;?php $file = $_GET[&apos;file&apos;];header (&quot;Content-type: octet/stream&quot;); //字节流，下载使用header (&quot;Content-disposition: attachment; filename=&quot;.$file.&quot;;&quot;); //下载的形式，这里是作为附件下载header(&quot;Content-Length: &quot;.filesize($file)); readfile($file); exit; ?&gt;]]></content>
      <categories>
        <category>-web 前端</category>
      </categories>
      <tags>
        <tag>-web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json和js的互转]]></title>
    <url>%2F2018%2F03%2F09%2Fjson%E5%92%8Cjs%E7%9A%84%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[JS对象转json 12var data = new Object();var json_data = JSON.stringify(data); （可用来成转换js数组） json转JS 12var json_data = $.getJSON();var data = $.parseJSON(json_data); .将json转换成js对象的方法： 1var json = eval(&apos;(&apos; + result + &apos;)&apos;); 通过上面这个表达式，就完成了将服务器端响应给客户端的Json格式的字符串解析成了一个Json（格式的）对象，名称为“json”，通过“json.”或者“json[]”的方式便可进行数据访问。]]></content>
      <categories>
        <category>-javascript</category>
      </categories>
      <tags>
        <tag>-web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码大全]]></title>
    <url>%2F2018%2F03%2F09%2Fhttp%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[XMLHttpRequest.status: 1xx-信息提示这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx响应。100-继续。101-切换协议。2xx-成功这类状态代码表明服务器成功地接受了客户端请求。200-确定。客户端请求已成功。201-已创建。202-已接受。203-非权威性信息。204-无内容。205-重置内容。206-部分内容。 3xx-重定向客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。301-对象已永久移走，即永久重定向。302-对象已临时移动。304-未修改。307-临时重定向。4xx-客户端错误发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。400-错误的请求。401-访问被拒绝。IIS定义了许多不同的401错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示：401.1-登录失败。401.2-服务器配置导致登录失败。401.3-由于ACL对资源的限制而未获得授权。401.4-筛选器授权失败。401.5-ISAPI/CGI应用程序授权失败。401.7–访问被Web服务器上的URL授权策略拒绝。这个错误代码为IIS6.0所专用。403-禁止访问：IIS定义了许多不同的403错误，它们指明更为具体的错误原因：403.1-执行访问被禁止。403.2-读访问被禁止。403.3-写访问被禁止。403.4-要求SSL。403.5-要求SSL128。403.6-IP地址被拒绝。403.7-要求客户端证书。403.8-站点访问被拒绝。403.9-用户数过多。403.10-配置无效。403.11-密码更改。403.12-拒绝访问映射表。403.13-客户端证书被吊销。403.14-拒绝目录列表。403.15-超出客户端访问许可。403.16-客户端证书不受信任或无效。403.17-客户端证书已过期或尚未生效。403.18-在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。403.19-不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用。403.20-Passport登录失败。这个错误代码为IIS6.0所专用。404-未找到。404.0-（无）–没有找到文件或目录。404.1-无法在所请求的端口上访问Web站点。404.2-Web服务扩展锁定策略阻止本请求。404.3-MIME映射策略阻止本请求。405-用来访问本页面的HTTP谓词不被允许（方法不被允许）406-客户端浏览器不接受所请求页面的MIME类型。407-要求进行代理身份验证。412-前提条件失败。413–请求实体太大。414-请求URI太长。415–不支持的媒体类型。416–所请求的范围无法满足。417–执行失败。423–锁定的错误。5xx-服务器错误服务器由于遇到错误而不能完成该请求。500-内部服务器错误。500.12-应用程序正忙于在Web服务器上重新启动。500.13-Web服务器太忙。500.15-不允许直接请求Global.asa。500.16–UNC授权凭据不正确。这个错误代码为IIS6.0所专用。500.18–URL授权存储不能打开。这个错误代码为IIS6.0所专用。500.100-内部ASP错误。501-页眉值指定了未实现的配置。502-Web服务器用作网关或代理服务器时收到了无效响应。502.1-CGI应用程序超时。502.2-CGI应用程序出错。application.503-服务不可用。这个错误代码为IIS6.0所专用。504-网关超时。505-HTTP版本不受支持。FTP1xx-肯定的初步答复这些状态代码指示一项操作已经成功开始，但客户端希望在继续操作新命令前得到另一个答复。110重新启动标记答复。120服务已就绪，在nnn分钟后开始。125数据连接已打开，正在开始传输。150文件状态正常，准备打开数据连接。2xx-肯定的完成答复一项操作已经成功完成。客户端可以执行新命令。200命令确定。202未执行命令，站点上的命令过多。211系统状态，或系统帮助答复。212目录状态。213文件状态。214帮助消息。215NAME系统类型，其中，NAME是AssignedNumbers文档中所列的正式系统名称。220服务就绪，可以执行新用户的请求。221服务关闭控制连接。如果适当，请注销。225数据连接打开，没有进行中的传输。226关闭数据连接。请求的文件操作已成功（例如，传输文件或放弃文件）。227进入被动模式(h1,h2,h3,h4,p1,p2)。230用户已登录，继续进行。250请求的文件操作正确，已完成。257已创建“PATHNAME”。3xx-肯定的中间答复该命令已成功，但服务器需要更多来自客户端的信息以完成对请求的处理。331用户名正确，需要密码。332需要登录帐户。350请求的文件操作正在等待进一步的信息。4xx-瞬态否定的完成答复该命令不成功，但错误是暂时的。如果客户端重试命令，可能会执行成功。421服务不可用，正在关闭控制连接。如果服务确定它必须关闭，将向任何命令发送这一应答。425无法打开数据连接。426Connectionclosed;transferaborted.450未执行请求的文件操作。文件不可用（例如，文件繁忙）。451请求的操作异常终止：正在处理本地错误。452未执行请求的操作。系统存储空间不够。5xx-永久性否定的完成答复该命令不成功，错误是永久性的。如果客户端重试命令，将再次出现同样的错误。500语法错误，命令无法识别。这可能包括诸如命令行太长之类的错误。501在参数中有语法错误。502未执行命令。503错误的命令序列。504未执行该参数的命令。530未登录。532存储文件需要帐户。550未执行请求的操作。文件不可用（例如，未找到文件，没有访问权限）。551请求的操作异常终止：未知的页面类型。552请求的文件操作异常终止：超出存储分配（对于当前目录或数据集）。553未执行请求的操作。不允许的文件名。常见的FTP状态代码及其原因150-FTP使用两个端口：21用于发送命令，20用于发送数据。状态代码150表示服务器准备在端口20上打开新连接，发送一些数据。226-命令在端口20上打开数据连接以执行操作，如传输文件。该操作成功完成，数据连接已关闭。230-客户端发送正确的密码后，显示该状态代码。它表示用户已成功登录。331-客户端发送用户名后，显示该状态代码。无论所提供的用户名是否为系统中的有效帐户，都将显示该状态代码。426-命令打开数据连接以执行操作，但该操作已被取消，数据连接已关闭。530-该状态代码表示用户无法登录，因为用户名和密码组合无效。如果使用某个用户帐户登录，可能键入错误的用户名或密码，也可能选择只允许匿名访问。如果使用匿名帐户登录，IIS的配置可能拒绝匿名访问。550-命令未被执行，因为指定的文件不可用。例如，要GET的文件并不存在，或试图将文件PUT到您没有写入权限的目录]]></content>
      <categories>
        <category>-http协议</category>
      </categories>
      <tags>
        <tag>-服务器知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F09%2Fhell%2F</url>
    <content type="text"><![CDATA[1这是我的第一篇博客日记，不知道写些啥比较好，随便写写，算是有了个开头，留下些痕迹。。。]]></content>
      <categories>
        <category>-生活笔记</category>
      </categories>
      <tags>
        <tag>-life</tag>
      </tags>
  </entry>
</search>
