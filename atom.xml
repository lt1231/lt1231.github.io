<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ting Blog</title>
  
  <subtitle>welcome to Ting blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liting.wang/"/>
  <updated>2018-07-02T02:36:37.344Z</updated>
  <id>http://liting.wang/</id>
  
  <author>
    <name>Tingli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你好世界</title>
    <link href="http://liting.wang/2018/07/03/%E5%95%8A/"/>
    <id>http://liting.wang/2018/07/03/啊/</id>
    <published>2018-07-03T05:12:08.848Z</published>
    <updated>2018-07-02T02:36:37.344Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="-学习指南" scheme="http://liting.wang/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://liting.wang/2018/07/03/%E6%88%91/"/>
    <id>http://liting.wang/2018/07/03/我/</id>
    <published>2018-07-03T02:15:56.211Z</published>
    <updated>2018-07-02T02:36:37.344Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="-学习指南" scheme="http://liting.wang/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈javascript闭包机制</title>
    <link href="http://liting.wang/2018/04/12/%E6%B5%85%E8%B0%88javascript%E9%97%AD%E5%8C%85%E6%9C%BA%E5%88%B6/"/>
    <id>http://liting.wang/2018/04/12/浅谈javascript闭包机制/</id>
    <published>2018-04-12T07:20:31.368Z</published>
    <updated>2018-04-12T07:35:20.062Z</updated>
    
    <content type="html"><![CDATA[<p>闭包（closure）是学习javascript语言的需要攻克的一个难点，也是特色，在初学js的过程中，我也十分纠结于这个点，不理解何为闭包，各种专业文献上的“闭包”定义非常抽象，越看越糊涂，在研读各路大神的博客之后，犹如醍醐灌顶，豁然开朗，</p><p><strong>闭包的概念</strong><br>所谓闭包，就是能够读取其他函数内部变量的函数，在js语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p><strong>变量作用域</strong><br>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var n=999;</span><br><span class="line"></span><br><span class="line">　　function f1()&#123;</span><br><span class="line">　　　　alert(n);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1(); // 999</span><br></pre></td></tr></table></figure><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">　　　　var n=999;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　alert(n); // error</span><br></pre></td></tr></table></figure><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">　　　　n=999;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1();</span><br><span class="line"></span><br><span class="line">　　alert(n); // 999</span><br></pre></td></tr></table></figure><p><strong>如何从外部读取局部变量？</strong><br>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p><p>那就是在函数的内部，再定义一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n=999;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n); // 999</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n=999;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); // 999</span><br></pre></td></tr></table></figure><p><strong>闭包的用途及优点</strong><br>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><p>怎么来理解这句话呢？请看下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n=999;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=function()&#123;n+=1&#125;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); // 999</span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); // 1000</span><br></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><p><strong>使用闭包的注意点</strong><br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br><strong>思考题</strong></p><p>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。</p><p>代码片段一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p>代码片段二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">本文转自阮一峰的学习Javascript闭包（Closure）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闭包（closure）是学习javascript语言的需要攻克的一个难点，也是特色，在初学js的过程中，我也十分纠结于这个点，不理解何为闭包，各种专业文献上的“闭包”定义非常抽象，越看越糊涂，在研读各路大神的博客之后，犹如醍醐灌顶，豁然开朗，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="-javascript" scheme="http://liting.wang/categories/javascript/"/>
    
    
      <category term="-前端开发" scheme="http://liting.wang/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>vue环境的搭建</title>
    <link href="http://liting.wang/2018/04/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E6%9E%B6Vue%E7%8E%AF%E5%A2%83/"/>
    <id>http://liting.wang/2018/04/03/手把手搭架Vue环境/</id>
    <published>2018-04-03T01:27:25.277Z</published>
    <updated>2018-04-12T07:28:32.760Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000008922234" target="_blank" rel="noopener">文章出处</a><br><a href="https://segmentfault.com/a/1190000008922234" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008922234</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008922234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章出处&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190
      
    
    </summary>
    
      <category term="-js脚本框架收录" scheme="http://liting.wang/categories/js%E8%84%9A%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%94%B6%E5%BD%95/"/>
    
    
      <category term="-前端、vue" scheme="http://liting.wang/tags/%E5%89%8D%E7%AB%AF%E3%80%81vue/"/>
    
  </entry>
  
  <entry>
    <title>前端大佬的博客收集</title>
    <link href="http://liting.wang/2018/04/03/%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"/>
    <id>http://liting.wang/2018/04/03/前端大佬的博客收集/</id>
    <published>2018-04-03T01:21:04.523Z</published>
    <updated>2018-04-12T07:28:04.209Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/daimomo000/article/details/62887152" target="_blank" rel="noopener">前端大佬的博客收集</a><br><a href="https://blog.csdn.net/daimomo000/article/details/62887152" target="_blank" rel="noopener">https://blog.csdn.net/daimomo000/article/details/62887152</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/daimomo000/article/details/62887152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端大佬的博客收集&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog
      
    
    </summary>
    
      <category term="-学习指南" scheme="http://liting.wang/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>关于SQL查询效率，100w数据，查询只要1秒</title>
    <link href="http://liting.wang/2018/04/03/%E5%85%B3%E4%BA%8ESQL%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%8C100w%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%8F%AA%E8%A6%811%E7%A7%92%EF%BC%8C%E4%B8%8E%E6%82%A8%E5%88%86%E4%BA%AB_/"/>
    <id>http://liting.wang/2018/04/03/关于SQL查询效率，100w数据，查询只要1秒，与您分享_/</id>
    <published>2018-04-03T01:11:01.866Z</published>
    <updated>2018-04-03T01:16:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>机器情况<br>p4: 2.4<br>内存: 1 G<br>os: windows 2003<br>数据库: ms sql server 2000<br>目的: 查询性能测试,比较两种查询的性能</p><p>SQL查询效率 step by step</p><p>– setp 1.<br>– 建表<br>create table t_userinfo<br>(<br>userid int identity(1,1) primary key nonclustered,<br>nick varchar(50) not null default ‘’,<br>classid int not null default 0,<br>writetime datetime not null default getdate()<br>)<br>go</p><p>– 建索引<br>create clustered index ix_userinfo_classid on t_userinfo(classid)<br>go</p><p>– step 2.</p><p>declare @i int<br>declare @k int<br>declare @nick varchar(10)<br>set @i = 1<br>while @i&lt;1000000<br>begin<br>set @k = @i % 10<br>set @nick = convert(varchar,@i)<br>insert into t_userinfo(nick,classid,writetime) values(@nick,@k,getdate())<br>set @i = @i + 1<br>end<br>– 耗时 08:27 ，需要耐心等待</p><p>– step 3.<br>select top 20 userid,nick,classid,writetime from t_userinfo<br>where userid not in<br>(<br>select top 900000 userid from t_userinfo order by userid asc<br>)</p><p>– 耗时 8 秒 ,够长的</p><p>– step 4.<br>select a.userid,b.nick,b.classid,b.writetime from<br>(<br>select top 20 a.userid from<br>(<br>select top 900020 userid from t_userinfo order by userid asc<br>) a order by a.userid desc<br>) a inner join t_userinfo b on a.userid = b.userid<br>order by a.userid asc</p><p>– 耗时 1 秒，太快了吧，不可以思议</p><p>– step 5 where 查询<br>select top 20 userid,nick,classid,writetime from t_userinfo<br>where classid = 1 and userid not in<br>(<br>select top 90000 userid from t_userinfo<br>where classid = 1<br>order by userid asc<br>)<br>– 耗时 2 秒</p><p>– step 6 where 查询<br>select a.userid,b.nick,b.classid,b.writetime from<br>(<br>select top 20 a.userid from<br>(<br>select top 90000 userid from t_userinfo<br>where classid = 1<br>order by userid asc<br>) a order by a.userid desc<br>) a inner join t_userinfo b on a.userid = b.userid<br>order by a.userid asc</p><p>– 查询分析器显示不到 1 秒.</p><p>查询效率分析：<br>子查询为确保消除重复值，必须为外部查询的每个结果都处理嵌套查询。在这种情况下可以考虑用联接查询来取代。<br>如果要用子查询，那就用EXISTS替代IN、用NOT EXISTS替代NOT IN。因为EXISTS引入的子查询只是测试是否存在符合子查询中指定条件的行，效率较高。无论在哪种情况下,NOT IN都是最低效的。因为它对子查询中的表执行了一个全表遍历。</p><p>建立合理的索引,避免扫描多余数据，避免表扫描！<br>几百万条数据，照样几十毫秒完成查询.</p><ol><li>SQL提高查询效率<br>2008-05-12 21:20<br>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li></ol><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num=0</p><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num=10 or num=20<br>可以这样查询：<br>select id from t where num=10<br>union all<br>select id from t where num=20</p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3</p><p>6.下面的查询也将导致全表扫描：<br>select id from t where name like ‘%abc%’<br>若要提高效率，可以考虑全文检索。</p><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>select id from t where num=@num<br>可以改为强制查询使用索引：<br>select id from t with(index(索引名)) where num=@num</p><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where num/2=100<br>应改为:<br>select id from t where num=100*2</p><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where substring(name,1,3)=’abc’–name以abc开头的id<br>select id from t where datediff(day,createdate,’2005-11-30’)=0–‘2005-11-30’生成的id<br>应改为:<br>select id from t where name like ‘abc%’<br>select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’</p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构：<br>select col1,col2 into #t from t where 1=0<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…)</p><p>13.很多时候用 exists 代替 in 是一个好的选择：<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num)</p><p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19.任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p><p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29.尽量避免大事务操作，提高系统并发能力。</p><p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理<br>1、避免将字段设为“允许为空”<br>2、数据表设计要规范<br>3、深入分析数据操作所要对数据库进行的操作<br>4、尽量不要使用临时表<br>5、多多使用事务<br>6、尽量不要使用游标<br>7、避免死锁<br>8、要注意读写锁的使用<br>9、不要打开大的数据集<br>10、不要使用服务器端游标<br>11、在程序编码时使用大数据量的数据库<br>12、不要给“性别”列创建索引<br>13、注意超时问题<br>14、不要使用Select <em><br>15、在细节表中插入纪录时，不要在主表执行Select MAX(ID)<br>16、尽量不要使用TEXT数据类型<br>17、使用参数查询<br>18、不要使用Insert导入大批的数据<br>19、学会分析查询<br>20、使用参照完整性<br>21、用INNER JOIN 和LEFT JOIN代替Where<br>///////////////////////////////////////////////////////////////////////////////////////////<br><a href="http://blog.sina.com.cn/s/blog_4b3d79a9010006gv.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b3d79a9010006gv.html</a><br>提高SQL查询效率（要点与技巧）：<br>? 技巧一：<br>问题类型：ACCESS数据库字段中含有日文片假名或其它不明字符时查询会提示内存溢出。<br>解决方法：修改查询语句<br>sql=”select </em> from tablename where column like ‘%”&amp;word&amp;”%’”<br>改为<br>sql=”select * from tablename”</p><h1 id="rs-filter-“-column-like-‘-”-amp-word-amp-”-’”"><a href="#rs-filter-“-column-like-‘-”-amp-word-amp-”-’”" class="headerlink" title="rs.filter = “ column like ‘%”&amp;word&amp;”%’”"></a>rs.filter = “ column like ‘%”&amp;word&amp;”%’”</h1><p>技巧二：<br>问题类型：如何用简易的办法实现类似百度的多关键词查询（多关键词用空格或其它符号间隔）。<br>解决方法：<br>‘//用空格分割查询字符串<br>ck=split(word,” “)<br>‘//得到分割后的数量<br>sck=UBound(ck)<br>sql=”select * tablename where”<br>在一个字段中查询<br>For i = 0 To sck<br>SQL = SQL &amp; tempJoinWord &amp; “(“ &amp; <em><br>“column like ‘“&amp;ck(i)&amp;”%’)”<br>tempJoinWord = “ and “<br>Next<br>在二个字段中同时查询<br>For i = 0 To sck<br>SQL = SQL &amp; tempJoinWord &amp; “(“ &amp; </em><br>“column like ‘“&amp;ck(i)&amp;”%’ or “ &amp; _<br>“column1 like ‘“&amp;ck(i)&amp;”%’)”<br>tempJoinWord = “ and “</p><h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><p>技巧三：大大提高查询效率的几种技巧</p><ol><li>尽量不要使用 or，使用or会引起全表扫描，将大大降低查询效率。</li><li>经过实践验证，charindex()并不比前面加%的like更能提高查询效率，并且charindex()会使索引失去作用（指sqlserver数据库）</li><li>column like ‘%”&amp;word&amp;”%’ 会使索引不起作用<br>column like ‘“&amp;word&amp;”%’ 会使索引起作用（去掉前面的%符号）<br>（指sqlserver数据库）</li><li>‘%”&amp;word&amp;”%’ 与’”&amp;word&amp;”%’ 在查询时的区别：<br>比如你的字段内容为 一个容易受伤的女人<br>‘%”&amp;word&amp;”%’ ：会通配所有字符串，不论查“受伤”还是查“一个”，都会显示结果。<br>‘“&amp;word&amp;”%’ ：只通配前面的字符串，例如查“受伤”是没有结果的，只有查“一个”，才会显示结果。</li><li>字段提取要按照“需多少、提多少”的原则，避免“select *”，尽量使用“select 字段1,字段2,字段3……..”。实践证明：每少提取一个字段，数据的提取速度就会有相应的提升。提升的速度还要看您舍弃的字段的大小来判断。</li><li>order by按聚集索引列排序效率最高。一个sqlserver数据表只能建立一个聚集索引，一般默认为ID，也可以改为其它的字段。</li><li>为你的表建立适当的索引，建立索引可以使你的查询速度提高几十几百倍。（指sqlserver数据库）<br>? 以下是建立索引与不建立索引的一个查询效率分析：<br>Sqlserver索引与查询效率分析。<br>表 News<br>字段<br>Id：自动编号<br>Title：文章标题<br>Author：作者<br>Content：内容<br>Star：优先级<br>Addtime：时间<br>记录：100万条<h1 id="测试机器：P4-2-8-1G内存-IDE硬盘"><a href="#测试机器：P4-2-8-1G内存-IDE硬盘" class="headerlink" title="测试机器：P4 2.8/1G内存/IDE硬盘"></a>测试机器：P4 2.8/1G内存/IDE硬盘</h1>方案1：<br>主键Id，默认为聚集索引，不建立其它非聚集索引<br>select * from News where Title like ‘%”&amp;word&amp;”%’ or Author like ‘%”&amp;word&amp;”%’ order by Id desc<br>从字段Title和Author中模糊检索，按Id排序<h1 id="查询时间：50秒"><a href="#查询时间：50秒" class="headerlink" title="查询时间：50秒"></a>查询时间：50秒</h1>方案2：<br>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br>select * from News where Title like ‘“&amp;word&amp;”%’ or Author like ‘“&amp;word&amp;”%’ order by Id desc<br>从字段Title和Author中模糊检索，按Id排序<h1 id="查询时间：2-2-5秒"><a href="#查询时间：2-2-5秒" class="headerlink" title="查询时间：2 - 2.5秒"></a>查询时间：2 - 2.5秒</h1>方案3：<br>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br>select * from News where Title like ‘“&amp;word&amp;”%’ or Author like ‘“&amp;word&amp;”%’ order by Star desc<br>从字段Title和Author中模糊检索，按Star排序<h1 id="查询时间：2-秒"><a href="#查询时间：2-秒" class="headerlink" title="查询时间：2 秒"></a>查询时间：2 秒</h1>方案4：<br>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br>select * from News where Title like ‘“&amp;word&amp;”%’ or Author like ‘“&amp;word&amp;”%’<br>从字段Title和Author中模糊检索，不排序<h1 id="查询时间：1-8-2-秒"><a href="#查询时间：1-8-2-秒" class="headerlink" title="查询时间：1.8 - 2 秒"></a>查询时间：1.8 - 2 秒</h1>方案5：<br>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br>select <em> from News where Title like ‘“&amp;word&amp;”%’<br>或<br>select </em> from News where Author like ‘“&amp;word&amp;”%’<br>从字段Title 或 Author中检索，不排序<br>查询时间：1秒<br>? 如何提高SQL语言的查询效率?<br>问：请问我如何才能提高SQL语言的查询效率呢？<br>答：这得从头说起：<br>由于SQL是面向结果而不是面向过程的查询语言，所以一般支持SQL语言的大型关系型数据库都使用一个基于查询成本的优化器，为即时查询提供一个最佳的执行策略。对于优化器，输入是一条查询语句，输出是一个执行策略。<br> 一条SQL查询语句可以有多种执行策略，优化器将估计出全部执行方法中所需时间最少的所谓成本最低的那一种方法。所有优化都是基于用记所使用的查询语句中的where子句，优化器对where子句中的优化主要用搜索参数(Serach Argument)。<br> 搜索参数的核心思想就是数据库使用表中字段的索引来查询数据，而不必直接查询记录中的数据。<br> 带有 =、&lt;、&lt;=、&gt;、&gt;= 等操作符的条件语句可以直接使用索引，如下列是搜索参数：<br> emp_id = “10001” 或 salary &gt; 3000 或  a =1 and c = 7<br> 而下列则不是搜索参数：<br> salary = emp_salary 或 dep_id != 10 或 salary * 12 &gt;= 3000 或 a=1 or c=7<br> 应当尽可能提供一些冗余的搜索参数，使优化器有更多的选择余地。请看以下3种方法：<br> 第一种方法：<br> select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (department.dep_code=”01”) and (employee.dep_code=”01”);<br> 它的搜索分析结果如下：<br> Estimate 2 I/O operations<br> Scan department using primary key<br> for rows where dep_code equals “01”<br> Estimate getting here 1 times<br> Scan employee sequentially<br> Estimate getting here 5 times<br> 第二种方法：<br> select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (department.dep_code=”01”);<br> 它的搜索分析结果如下：<br> Estimate 2 I/O operations<br> Scan department using primary key<br> for rows where dep_code equals “01”<br> Estimate getting here 1 times<br> Scan employee sequentially<br> Estimate getting here 5 times<br> 第一种方法与第二种运行效率相同，但第一种方法最好，因为它为优化器提供了更多的选择机会。<br> 第三种方法：<br> select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (employee.dep_code=”01”);<br> 这种方法最不好，因为它无法使用索引，也就是无法优化……<br>使用SQL语句时应注意以下几点：<br> 1、避免使用不兼容的数据类型。例如，Float和Integer，Char和Varchar，Binary和Long Binary不兼容的。数据类型的不兼容可能使优化器无法执行一些本可以进行的优化操作。例如：<br> select emp_name form employee where salary &gt; 3000;<br> 在此语句中若salary是Float类型的，则优化器很难对其进行优化，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。<br> 2、尽量不要使用表达式，因它在编绎时是无法得到的，所以SQL只能使用其平均密度来估计将要命中的记录数。<br> 3、避免对搜索参数使用其他的数学操作符。如：<pre><code>select emp_name from employee where salary * 12 &gt; 3000;应改为：select emp_name from employee where salary  &gt; 250;</code></pre> 4、避免使用 != 或 &lt;&gt; 等这样的操作符，因为它会使系统无法使用索引，而只能直接搜索表中的数据。<br>? ORACAL中的应用<br>一个1600万数据表－－短信上行表TBL_SMS_MO<br>结构：<br>CREATE TABLE TBL_SMS_MO<br>(<br>SMS_ID NUMBER,<br>MO_ID VARCHAR2(50),<br>MOBILE VARCHAR2(11),<br>SPNUMBER VARCHAR2(20),<br>MESSAGE VARCHAR2(150),<br>TRADE_CODE VARCHAR2(20),<br>LINK_ID VARCHAR2(50),<br>GATEWAY_ID NUMBER,<br>GATEWAY_PORT NUMBER,<br>MO_TIME DATE DEFAULT SYSDATE<br>);<br>CREATE INDEX IDX_MO_DATE ON TBL_SMS_MO (MO_TIME)<br>PCTFREE 10<br>INITRANS 2<br>MAXTRANS 255<br>STORAGE<br>(<br> INITIAL 1M<br> NEXT 1M<br> MINEXTENTS 1<br> MAXEXTENTS UNLIMITED<br> PCTINCREASE 0<br>);<br>CREATE INDEX IDX_MO_MOBILE ON TBL_SMS_MO (MOBILE)<br>PCTFREE 10<br>INITRANS 2<br>MAXTRANS 255<br>STORAGE<br>(<br> INITIAL 64K<br> NEXT 1M<br> MINEXTENTS 1<br> MAXEXTENTS UNLIMITED<br> PCTINCREASE 0<br>);<br>　　问题：从表中查询某时间段内某手机发送的短消息，如下SQL语句：<br>SELECT MOBILE,MESSAGE,TRADE_CODE,MO_TIME<br>FROM TBL_SMS_MO<br>WHERE MOBILE=’130XXXXXXXX’<br>AND MO_TIME BETWEEN TO_DATE(‘2006-04-01’,’YYYY-MM-DD HH24:MI:SS’) AND TO_DATE(‘2006-04-07’,’YYYY-MM-DD HH24:MI:SS’)<br>ORDER BY MO_TIME DESC<br>返回结果大约需要10分钟，应用于网页查询，简直难以忍受。<br>分析：<br>在PL/SQL Developer，点击“Explain Plan”按钮（或F5键），对SQL进行分析，发现缺省使用的索引是IDX_MO_DATE。问题可能出在这里，因为相对于总数量1600万数据来说，都mobile的数据是很少的，如果使用IDX_MO_MOBILE比较容易锁定数据。<br>如下优化：<br>SELECT /<em>+ index(TBL_SMS_MO IDX_MO_MOBILE) </em>/ MOBILE,MESSAGE,TRADE_CODE,MO_TIME<br>FROM TBL_SMS_MO<br>WHERE MOBILE=’130XXXXXXXX’<br>AND MO_TIME BETWEEN TO_DATE(‘2006-04-01’,’YYYY-MM-DD HH24:MI:SS’) AND TO_DATE(‘2006-04-07’,’YYYY-MM-DD HH24:MI:SS’)<br>ORDER BY MO_TIME DESC<br>测试：<br>按F8运行这个SQL，哇～… … 2.360s，这就是差别。<br>用索引提高SQL Server性能<br>特别说明<br>　　在微软的SQL Server系统中通过有效的使用索引可以提高数据库的查询性能，但是性能的提高取决于数据库的实现。在本文中将会告诉你如何实现索引并有效的提高数据库的性能。　<br>　　<br>　　在关系型数据库中使用索引能够提高数据库性能，这一点是非常明显的。用的索引越多，从数据库系统中得到数据的速度就越快。然而，需要注意的是，用的索引越多，向数据库系统中插入新数据所花费的时间就越多。在本文中，你将了解到微软的SQL Server数据库所支持的各种不同类型的索引，在这里你将了解到如何使用不同的方法来实现索引，通过这些不同的实现方法，你在数据库的读性能方面得到的远比在数据库的整体性能方面的损失要多得多。<br>　　<br>　　索引的定义<br>　　索引是数据库的工具，通过使用索引，在数据库中获取数据的时候，就可以不用扫描数据库中的所有数据记录，这样能够提高系统获取数据的性能。使用索引可以改变数据的组织方式，使得所有的数据都是按照相似的结构来组织的，这样就可以很容易地实现数据的检索访问。索引是按照列来创建的，这样就可以根据索引列中的值来帮助数据库找到相应的数据。<br>　　<br>　　索引的类型<br>　　微软的SQL Server 支持两种类型的索引：clustered 索引和nonclustered索引。Clustered 索引在数据表中按照物理顺序存储数据。因为在表中只有一个物理顺序，所以在每个表中只能有一个clustered索引。在查找某个范围内的数据时，Clustered索引是一种非常有效的索引，因为这些数据在存储的时候已经按照物理顺序排好序了。<br>　　<br>　　Nonclustered索引不会影响到下面的物理存储，但是它是由数据行指针构成的。如果已经存在一个clustered索引，在nonclustered中的索引指针将包含clustered索引的位置参考。这些索引比数据更紧促，而且对这些索引的扫描速度比对实际的数据表扫描要快得多。<br>　　<br>　　如何实现索引<br>　　数据库可以自动创建某些索引。例如，微软的SQL Server系统通过自动创建唯一索引来强制实现UNIQUE约束，这样可以确保在数据库中不会插入重复数据。也可以使用CREATE INDEX语句或者通过SQL Server Enterprise Manager来创建其他索引，SQL Server Enterprise Manager还有一个索引创建模板来指导你如何创建索引。<br>　　<br>　　得到更好的性能<br>　　虽然索引可以带来性能上的优势，但是同时也将带来一定的代价。虽然SQL Server系统允许你在每个数据表中创建多达256个nonclustered索引，但是建议不要使用这么多的索引。因为索引需要在内存和物理磁盘驱动器上使用更多的存储空间。在执行插入声明的过程中可能会在一定程度上导致系统性能的下降，因为在插入数据的时候是需要根据索引的顺序插入，而不是在第一个可用的位置直接插入数据，这样一来，存在的索引越多将导致插入或者更新声明所需要的时间就越多。<br>　　<br>　　在使用SQL Server系统创建索引的时候，建议参照下面的创建准则来实现：<br>　　<br>　　正确的选择数据类型<br>　　在索引中使用某些数据类型可以提高数据库系统的效率，例如，Int，bigint， smallint，和tinyint等这些数据类型都非常适合于用在索引中，因为他们都占用相同大小的空间并且可以很容易地实现比较操作。其他的数据类型如char和varchar的效率都非常低，因为这些数据类型都不适合于执行数学操作，并且执行比较操作的时间都比上面提到数据类型要长。<br>　　<br>　　确保在使用的过程中正确的利用索引值<br>　　在执行查询操作时，可能所使用的列只是clustered的一部分，这时尤其要注意的是如何使用这些数据。当用这些数据列作为参数调用函数时，这些函数可能会使现有的排序优势失效。例如，使用日期值作为索引，而为了实现比较操作，可能需要将这个日期值转换为字符串，这样将导致在查询过程中无法用到这个日期索引值。<br>　　<br>　　在创建多列索引时，需要注意列的顺序<br>　　数据库将根据第一列索引的值来排列记录，然后进一步根据第二列的值来排序，依次排序直到最后一个索引排序完毕。哪一列唯一数据值较少，哪一列就应该为第一个索引，这样可以确保数据可以通过索引进一步交叉排序。<br>　　<br>　　在clustered索引中限制列的数量<br>　　在clustered索引中用到的列越多，在nonclustered索引中包含的clustered索引参考位置就越多，需要存储的数据也就越多。这样将增加包含索引的数据表的大小，并且将增加基于索引的搜索时间。<br>　　<br>　　避免频繁更新clustered索引数据列<br>　　由于nonclustered 索引依赖于clustered 索引，所以如果构成clustered 索引的数据列频繁更新，将导致在nonclustered中存储的行定位器也将随之频繁更新。对于所有与这些列相关的查询来说，如果发生记录被锁定的情况时，这将可能导致性能成本的增加。<br>　　<br>　　分开操作（如果可能的话）<br>　　对于一个表来说，如果需要进行频繁的执行插入、更新操作，同时还有大量读操作的话，在可能的情况下尝试将这个表分开操作。所有的插入和更新操作可以在一个没有索引的表中操作，然后将其复制到另外一个表中，在这个表里有大量的索引可以优化读数据的能力。<br>　　<br>　　适当的重建索引<br>　　Nonclustered索引包含clustered索引的指针，这样一来Nonclustered索引将从属于clustered 索引。当重建clustered索引时，首先是丢弃原来的索引，然后再使用CREATE INDEX 来创建索引，或者在使用CREATE INDEX 声明的同时将DROP_EXISTING 子句作为重建索引的一部分。将丢弃和创建分为几步将会导致多次重建nonclustered 索引，而不象使用DROP_EXISTING 子句那样，只重建一次nonclustered 索引。<br>　　<br>　　明智的使用填充因子<br>　　数据存储在那些具有固定大小的连续内存页面内。随着新的记录行的加入，数据内存页将逐渐被填满，系统就必须执行数据页的拆分工作，通过这个拆分工作将部分数据转移到下一个新的页面当中。这样的拆分之后，将加重系统的负担，并且会导致存储的数据支离破碎。填充因子可以维护数据之间的缺口，一般在创建索引的时候，该索引的填充因子就已经被设置好了。这样一来，可以减少插入数据所引起的页面分裂的次数。因为只是在创建索引的时候才维护空间的大小，在增加数据或者更新数据时不会去维护空间的大小。因此，要想能够充分的利用填充因子，就必须周期性的重建索引。由填充因子所造成的缺口将导致读性能的下降，因为随着数据库的扩张，越来越多的磁盘存取工作需要读取数据。所以，在读的次数超过写的次数的时候，很重要的一点是考虑使用填充因子还是使用缺省方式合适。<br>　　<br>　　管理层的决策<br>　　通过有效的使用索引，可以在微软的SQL Server系统中实现很好的查询功能，但是使用索引的效率取决于几种不同的实现决策。在索引的性能平衡方面，要做出正确的数据库管理决策意味着需要在良好的性能和困境中抉择。在特定的情况下，本文给出的一些建议将有助于你做出正确的决策</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机器情况&lt;br&gt;p4: 2.4&lt;br&gt;内存: 1 G&lt;br&gt;os: windows 2003&lt;br&gt;数据库: ms sql server 2000&lt;br&gt;目的: 查询性能测试,比较两种查询的性能&lt;/p&gt;
&lt;p&gt;SQL查询效率 step by step&lt;/p&gt;
&lt;p&gt;– se
      
    
    </summary>
    
      <category term="-sqlserver" scheme="http://liting.wang/categories/sqlserver/"/>
    
    
      <category term="-后台" scheme="http://liting.wang/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>git操作命令总结</title>
    <link href="http://liting.wang/2018/04/02/git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://liting.wang/2018/04/02/git操作命令总结/</id>
    <published>2018-04-02T02:18:22.412Z</published>
    <updated>2018-04-12T07:24:48.706Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/3/23/16251a633280d5e8?imageView2/1/w/1304/h/734/q/85/interlace/1" alt="这里写图片描述"><br>HEAD：当前commit引用</p><p>$ git version   # → git版本</p><p>$ git branch   # → 查看本地所有的分支</p><p>$ git branch   # → 查看本地所有的分支<br><a id="more"></a><br>$ git branch -r # → 查看所有远程的分支</p><p>$ git branch -a # → 查看所有远程分支和本地分支</p><p>$ git branch -d <branchname> # → 删除本地branchname分支</branchname></p><p>$ git branch -m brancholdname branchnewname # → 重命名分支</p><p>$ git branch <branchname> # → 创建branchname分支</branchname></p><p>$ git checkout <branchname> # → 切换分支到branchname</branchname></p><p>$ git checkout -b <branchname> # → 等同于执行上两步，即创建新的分支并切换到该分支</branchname></p><p>$ git checkout – xx/xx # → 回滚单个文件</p><p>$ git pull origin master:master # → 将远程origin主机的master分支合并到当前master分支,冒号后面的部分表示当前本地所在的分支</p><p>$ git push origin -d <branchname>   # → 删除远程branchname分支</branchname></p><p>$ git fetch –p # → 更新分支</p><p>$ git status # → 查看仓库状态</p><p>$ git add xx # → 把xx文件添加到暂存区去</p><p>$ git commit -m ‘ ‘  # → 提交文件 -m 后面的是注释(不建议使用?)</p><p>$ git commit -am(-a -m) # → 提交所有的修改，等同于上两步(不建议使用?)</p><p>$ git commit ./xx   # → 等同于git add ./xx + git commit（建议使用?）</p><p>$ git commit –amend # → 将暂存区和当前commit合并创建一个新commit去替换当前commit</p><p>$ git stash # → 把当前的工作隐藏起来 等以后恢复现场后继续工作</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a813d38a3a?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git stash pop # → 恢复工作现场（恢复隐藏的文件，同时删除stash列表中对应的内容）</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a81c9e0bd1?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git fetch –all  # → 将远程主机的更新全部取回本地</p><p>$ git merge origin/master  # → 在本地（当前）分支上合并远程分支</p><p>$ git merge –abort  # → 终止本次merge，并回到merge前的状态（?）</p><p>$ git pull origin master  # → 从远程获取最新版本并merge到本地等同于</p><p>$ git fetch origin master + $ git merge origin/master（前者更安全一些）</p><p>$ git push origin master   # → 将本地master分支推送到远程origin主机的master分支</p><p>$ git log xx  # → 查看xx文件的commit记录</p><p>$ git log -p xx   # → 查看xx文件每次提交的diff</p><p>$ git log –pretty=oneline xx  # → 查看xx文件提交的历史记录（只显示哈希值和提交说明）</p><p>$ git log –pretty=raw  # → 查看commit之间的父子关系（root commit是没有父提交的）</p><p>$ git log –graph  # → 查看当前分支commit生成的树状图</p><p>$ git diff HEAD HEAD^1 – xx  # → 查看xx文件不同版本之间的差异</p><p>$ git diff HEAD~1  # → 显示父节点的提交</p><p><strong> git中‘~’和‘^’的区别：</strong></p><p>(<commit>|HEAD)^n，指的是HEAD的第n个父提交，可以通过在“^”后面跟上一个数字，表示第几个父提交，“^”相当“^1”。例如：HEAD^2 表示HEAD的第二次父提交。(<commit>|HEAD)~n，指的是HEAD的第n个祖先提交，可以通过在“~”后面跟上一个数字，表示第几个祖父提交，“~”相当“~1”，“~n”相当于连续的<n>个“^”。例如：HEAD~2 表示HEAD的第一个父提交的第一个父提交。</n></commit></commit></p><p>等式1：HEAD~ === HEAD^ === HEAD^1 </p><p>等式2：HEAD~2 === HEAD^^ === HEAD^1^1</p><p>$ git diff –staged/–cached  # → 显示暂存区和上一次提交的不同，git add之前忘diff的后悔药</p><p>$ git show –stat  # → 查看最后一次的修改</p><p>$ git show HEAD  # → 查看指定版本的修改（可省略HEAD，默认当前版本） 同上</p><p>$ git show HEAD xxx  # → 查看指定版本xx文件的修改（可省略HEAD，默认当前版本）</p><p>$ git reset –hard HEAD  # → 回滚到指定版本，同时清空工作目录的所有改动</p><p>$ git reset –soft HEAD  # → 回滚到指定版本，同时保留工作目录和暂存区的内容，并把重置的位置所导致的新的文件差异放进暂存区</p><p>$ git reset –mixed HEAD  # → （默认）回滚到指定版本，同时保留工作目录的内容，并清空暂存区</p><p>$ git reset –hard origin/master  # → 将本地master与远程master同步</p><p> –hard –soft –mixed的区别可用下图表示：<br> 假设当前commit和工作目录如下所示：<img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a817765b40?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>如果这时你执行：git reset –hard HEAD^<br><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a85877b2ab?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>改动全部消失，未跟踪文件除外⬆️<br><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a857be9277?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>git show –stat查看此时对应的当前commit⬆️<br>2⃣️如果这时你执行：git reset –soft HEAD^<br><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a857c98476?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>reset之前commit的改动被放进暂存区，并保留了工作目录⬆️</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a857be9277?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>git show –stat查看此时对应的当前commit⬆️<br>如果这时你执行：git reset –mixed HEAD^<br><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a8902e6daf?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>同–soft一样保留了工作目录，但暂存区被全部被清空，之前commit的改动被放到未追踪文件中⬆️<br><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a857be9277?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>git show –stat查看此时对应的当前commit⬆️<br>$ git reflog show –date=iso <branch name="">  # → 查看分支的创建时间</branch></p><p>$ git branch -r | awk ‘{print $1}’ | egrep -v -f /dev/fd/0 &lt;(git branch -vv | grep origin) | awk ‘{print $1}’ | xargs git branch -d  # → 删除在远程已被删除的本地分支 (慎用)</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a88cf56929?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git remote show origin  # → 查看remote地址，远程分支，还有本地分支与之相对应关系等信息。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a85e7c325c?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git remote prune origin  # → 删除了那些远程仓库不存在的分支 === git fetch -p</p><p>$ git config  # → 查看和编辑git的配置<br>查看格式：<br>git config [–local|–global|–system] -l</p><p>$ git config –local -l  # →  查看仓库级的config</p><p>$ git config –global -l  # →  查看全局级的config</p><p>编辑格式：<br>git config [–local|–global|–system] -e</p><p>$ git config –local -e # →  编辑仓库级的config</p><p>$ git config –global -e # →  编辑全局级的config</p><p>修改格式：<br>git config [–local|–global|–system] section.key value</p><p>$ git config –local push.default ‘simple’  # →  修改仓库级的push.default的默认行为</p><p>$ git config –global push.default ‘current’  # →  修改全局级的push.default的默认行为</p><ul><li>关于git default配置这里</li></ul><p>增加格式:<br>git config [–local|–global|–system] –add section.key value(默认是添加在local配置中)</p><p>$ git config –add cat.name songhw  # →  local配置写入 cat.name = songhw</p><p>$ git config –local –add cat.name songhw  # →  等同于上一步</p><p>$ git config –global –add cat.name lhammer  # →  global配置写入 cat.name = lhammer</p><p>获取格式：<br>git config [–local|–global|–system] –get section.key(默认是获取local配置中内容)</p><p>$ git config –get cat.name  # →  输出songhw</p><p>$ git config –local –get cat.name  # →  输出结果同上一步</p><p>$ git config –global –get cat.name  # →  输出lhammer</p><p>删除格式：<br>git config [–local|–global|–system] –unset section.key</p><p>$ git config –local –unset cat.name # →  删除local配置中的cat.name = songhw</p><p>$ git config –global –unset cat.name # →  删除local配置中的cat.name = lhammer</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a88d1d646a?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git rebase master  # → 在当前分支对master执行rebase</p><p>$ git rebase -i 目标commit  # → 修改历史某一次提交</p><p>把需要修改的commit对应的操作指令从pick改为edit</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a892c95e65?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a8a896cb2a?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ gitrebase –continue  # → 接上一步修改完之后，继续rebase</p><p>$ gitrebase –onto HEAD HEAD^1 <branchname>   # → 撤销指定的commit，即消失在历史中</branchname></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603f4a8bad0fa3e?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"></p><p>$ git push origin <brancename> -f  # → 忽略冲突，强制提交</brancename></p><p>$ git revert HEAD  # → 撤销指定的commit（?）</p><p> git revert和git rebase –onto的区别： git revert会增加一条新的commit，它的内容与指定commit的修改是相反的，两次相互抵消从而达到撤销的效果，并且在commit历史中，会存在两条提交，一条原始commit，一条它的反转commit，而git rebase –onto是直接将commit从历史记录中直接删除。</p><p>$ git checkout  HEAD(c08de9a)  # → c08de9a为brance删除之前所在的位置</p><p>$ git checkout -b <brancename>  # → 重新创建<brancename>，找回删除的分支</brancename></brancename></p><p>注：不再被引用直接或间接指向的commit会在一定的时间被git回收，所以通过reflog操作找回删除的分支一定要及时，不然有可能由于commit被回收导致永远也找不回了<br>$ git tag  # → 列出所有<code>tag</code></p><p>$ git tag -l version1.*  # → 只会列出1.几的版本</p><p>$ git tag <tagname>(version 1.0)  # → 创建轻量级的<code>tag</code></tagname></p><p>$ git tag -a <tagname>(version1.0) -m ‘first version’  # → 创建带有信息的<code>tag</code></tagname></p><p>$ git tag -d <tagname>(version 1.0)  # → 删除指定<code>tag</code></tagname></p><p>$ git checkout <tagname>(version 1.0)  # → 检出指定<code>tag</code></tagname></p><p>作者：LHammer<br>链接：<a href="https://juejin.im/post/5a2cdfe26fb9a0452936b07f" target="_blank" rel="noopener">https://juejin.im/post/5a2cdfe26fb9a0452936b07f</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/23/16251a633280d5e8?imageView2/1/w/1304/h/734/q/85/interlace/1&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;HEAD：当前commit引用&lt;/p&gt;
&lt;p&gt;$ git version   # → git版本&lt;/p&gt;
&lt;p&gt;$ git branch   # → 查看本地所有的分支&lt;/p&gt;
&lt;p&gt;$ git branch   # → 查看本地所有的分支&lt;br&gt;
    
    </summary>
    
      <category term="-github" scheme="http://liting.wang/categories/github/"/>
    
    
      <category term="-前端开发" scheme="http://liting.wang/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何处理嵌套的表格边框</title>
    <link href="http://liting.wang/2018/03/09/%E8%A1%A8%E6%A0%BC%E5%B5%8C%E5%A5%97%E8%BE%B9%E6%A1%86%E5%A4%84%E7%90%86/"/>
    <id>http://liting.wang/2018/03/09/表格嵌套边框处理/</id>
    <published>2018-03-09T05:35:42.598Z</published>
    <updated>2018-04-12T07:27:18.944Z</updated>
    
    <content type="html"><![CDATA[<p><code>外层table与内层table嵌套，内外表格都需边框时，设置“border=1”，但边框会重复，造成某些地方边框粗，有些地方边框细的问题。</code></p><p>解决办法：<br>外表格样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;border-collapse: collapse;”&gt;</span><br></pre></td></tr></table></figure></p><p>内表格样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;border-collapse: collapse;border-width:0px; border-style:hidden;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>按照如上设置：嵌套表格看起来就像一个表格一样，非常漂亮！</code><br><a href="https://www.cnblogs.com/sunflower627/p/3548368.html" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;外层table与内层table嵌套，内外表格都需边框时，设置“border=1”，但边框会重复，造成某些地方边框粗，有些地方边框细的问题。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决办法：&lt;br&gt;外表格样式：&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="-工作笔录" scheme="http://liting.wang/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E5%BD%95/"/>
    
    
      <category term="-css样式" scheme="http://liting.wang/tags/css%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则验证手机号，邮箱</title>
    <link href="http://liting.wang/2018/03/09/%E6%AD%A3%E5%88%99%E9%AA%8C%E8%AF%81%E6%89%8B%E6%9C%BA%E5%8F%B7%E5%92%8C%E9%82%AE%E7%AE%B1/"/>
    <id>http://liting.wang/2018/03/09/正则验证手机号和邮箱/</id>
    <published>2018-03-09T05:35:42.596Z</published>
    <updated>2018-04-12T07:35:48.365Z</updated>
    
    <content type="html"><![CDATA[<p>手机号验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1[3|4|5|7|8][0-9]&#123;9&#125;$</span><br></pre></td></tr></table></figure></p><blockquote><p>这是精准的手机号验证格式<br>解释 ：开头数字是1，第二位数字，是3到8的任何一个数字，后面是0到9的任意数字，一共9个字符</p></blockquote><p>邮箱验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[a-z0-9!#$%&amp;&apos;*+\/=?^_`&#123;|&#125;~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i</span><br></pre></td></tr></table></figure></p><p>验证手机号或者邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/（^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$）|（^[a-z0-9!#$%&amp;&apos;*+\/=?^_`&#123;|&#125;~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$）/i</span><br></pre></td></tr></table></figure><p>正则表达式的两种定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$/;</span><br><span class="line">var reg = new RegExp(&apos;^0&#123;0,1&#125;(13[0-9]|15[7-9]|153|156|18[7-9])[0-9]&#123;8&#125;$&apos;);</span><br><span class="line">reg.test(&apos;123@qq.com&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;手机号验证&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="-工作笔录" scheme="http://liting.wang/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E5%BD%95/"/>
    
    
      <category term="-前端开发" scheme="http://liting.wang/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>下载控件（点击链接下载文件）</title>
    <link href="http://liting.wang/2018/03/09/%E4%B8%8B%E8%BD%BD%E6%8E%A7%E4%BB%B6/"/>
    <id>http://liting.wang/2018/03/09/下载控件/</id>
    <published>2018-03-09T05:35:42.595Z</published>
    <updated>2018-04-12T07:24:22.897Z</updated>
    
    <content type="html"><![CDATA[<p>html部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;download.php?file=这里写你需要下载的文件地址&quot;&gt;UCdownload&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>php部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$file = $_GET[&apos;file&apos;];</span><br><span class="line">header (&quot;Content-type: octet/stream&quot;);  //字节流，下载使用</span><br><span class="line">header (&quot;Content-disposition: attachment; filename=&quot;.$file.&quot;;&quot;); //下载的形式，这里是作为附件下载</span><br><span class="line">header(&quot;Content-Length: &quot;.filesize($file));  </span><br><span class="line">readfile($file);  </span><br><span class="line">exit;    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;html部分&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="-工作笔录" scheme="http://liting.wang/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>json和js的互转</title>
    <link href="http://liting.wang/2018/03/09/json%E5%92%8Cjs%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
    <id>http://liting.wang/2018/03/09/json和js的互转/</id>
    <published>2018-03-09T05:35:42.594Z</published>
    <updated>2018-04-12T07:26:02.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JS对象转json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new Object();</span><br><span class="line">var json_data = JSON.stringify(data);</span><br></pre></td></tr></table></figure><blockquote><p>（可用来成转换js数组）</p></blockquote><p><strong>json转JS</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var json_data = $.getJSON();</span><br><span class="line">var data = $.parseJSON(json_data);</span><br></pre></td></tr></table></figure><p><strong>.将json转换成js对象的方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var json = eval(&apos;(&apos; + result + &apos;)&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>通过上面这个表达式，就完成了将服务器端响应给客户端的Json格式的字符串解析成了一个Json（格式的）对象，名称为“json”，通过“json.”或者“json[]”的方式便可进行数据访问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JS对象转json&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="-工作笔录" scheme="http://liting.wang/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E5%BD%95/"/>
    
    
      <category term="-前端开发、javascript" scheme="http://liting.wang/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E3%80%81javascript/"/>
    
  </entry>
  
  <entry>
    <title>http状态码大全</title>
    <link href="http://liting.wang/2018/03/09/http%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>http://liting.wang/2018/03/09/http状态码大全/</id>
    <published>2018-03-09T05:35:42.593Z</published>
    <updated>2018-04-12T07:26:50.720Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><p>XMLHttpRequest.status:</p><p>1xx-信息提示<br>这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx响应。<br>100-继续。<br>101-切换协议。<br><a id="more"></a><br>2xx-成功<br>这类状态代码表明服务器成功地接受了客户端请求。<br>200-确定。客户端请求已成功。<br>201-已创建。<br>202-已接受。<br>203-非权威性信息。<br>204-无内容。<br>205-重置内容。<br>206-部分内容。  </p><p>3xx-重定向<br>客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。<br>301-对象已永久移走，即永久重定向。<br>302-对象已临时移动。<br>304-未修改。<br>307-临时重定向。<br>4xx-客户端错误<br>发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。400-错误的请求。<br>401-访问被拒绝。IIS定义了许多不同的401错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示：<br>401.1-登录失败。<br>401.2-服务器配置导致登录失败。<br>401.3-由于ACL对资源的限制而未获得授权。<br>401.4-筛选器授权失败。<br>401.5-ISAPI/CGI应用程序授权失败。<br>401.7–访问被Web服务器上的URL授权策略拒绝。这个错误代码为IIS6.0所专用。<br>403-禁止访问：IIS定义了许多不同的403错误，它们指明更为具体的错误原因：<br>403.1-执行访问被禁止。<br>403.2-读访问被禁止。<br>403.3-写访问被禁止。<br>403.4-要求SSL。<br>403.5-要求SSL128。<br>403.6-IP地址被拒绝。<br>403.7-要求客户端证书。<br>403.8-站点访问被拒绝。<br>403.9-用户数过多。<br>403.10-配置无效。<br>403.11-密码更改。<br>403.12-拒绝访问映射表。<br>403.13-客户端证书被吊销。<br>403.14-拒绝目录列表。<br>403.15-超出客户端访问许可。<br>403.16-客户端证书不受信任或无效。<br>403.17-客户端证书已过期或尚未生效。<br>403.18-在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。<br>403.19-不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用。<br>403.20-Passport登录失败。这个错误代码为IIS6.0所专用。<br>404-未找到。<br>404.0-（无）–没有找到文件或目录。<br>404.1-无法在所请求的端口上访问Web站点。<br>404.2-Web服务扩展锁定策略阻止本请求。<br>404.3-MIME映射策略阻止本请求。<br>405-用来访问本页面的HTTP谓词不被允许（方法不被允许）<br>406-客户端浏览器不接受所请求页面的MIME类型。<br>407-要求进行代理身份验证。<br>412-前提条件失败。<br>413–请求实体太大。<br>414-请求URI太长。<br>415–不支持的媒体类型。<br>416–所请求的范围无法满足。<br>417–执行失败。<br>423–锁定的错误。<br>5xx-服务器错误<br>服务器由于遇到错误而不能完成该请求。<br>500-内部服务器错误。<br>500.12-应用程序正忙于在Web服务器上重新启动。<br>500.13-Web服务器太忙。<br>500.15-不允许直接请求Global.asa。<br>500.16–UNC授权凭据不正确。这个错误代码为IIS6.0所专用。<br>500.18–URL授权存储不能打开。这个错误代码为IIS6.0所专用。<br>500.100-内部ASP错误。<br>501-页眉值指定了未实现的配置。<br>502-Web服务器用作网关或代理服务器时收到了无效响应。<br>502.1-CGI应用程序超时。<br>502.2-CGI应用程序出错。application.<br>503-服务不可用。这个错误代码为IIS6.0所专用。<br>504-网关超时。<br>505-HTTP版本不受支持。<br>FTP<br>1xx-肯定的初步答复<br>这些状态代码指示一项操作已经成功开始，但客户端希望在继续操作新命令前得到另一个答复。<br>110重新启动标记答复。<br>120服务已就绪，在nnn分钟后开始。<br>125数据连接已打开，正在开始传输。<br>150文件状态正常，准备打开数据连接。<br>2xx-肯定的完成答复<br>一项操作已经成功完成。客户端可以执行新命令。200命令确定。<br>202未执行命令，站点上的命令过多。<br>211系统状态，或系统帮助答复。<br>212目录状态。<br>213文件状态。<br>214帮助消息。<br>215NAME系统类型，其中，NAME是AssignedNumbers文档中所列的正式系统名称。<br>220服务就绪，可以执行新用户的请求。<br>221服务关闭控制连接。如果适当，请注销。<br>225数据连接打开，没有进行中的传输。<br>226关闭数据连接。请求的文件操作已成功（例如，传输文件或放弃文件）。<br>227进入被动模式(h1,h2,h3,h4,p1,p2)。<br>230用户已登录，继续进行。<br>250请求的文件操作正确，已完成。<br>257已创建“PATHNAME”。<br>3xx-肯定的中间答复<br>该命令已成功，但服务器需要更多来自客户端的信息以完成对请求的处理。331用户名正确，需要密码。<br>332需要登录帐户。<br>350请求的文件操作正在等待进一步的信息。<br>4xx-瞬态否定的完成答复<br>该命令不成功，但错误是暂时的。如果客户端重试命令，可能会执行成功。421服务不可用，正在关闭控制连接。如果服务确定它必须关闭，将向任何命令发送这一应答。<br>425无法打开数据连接。<br>426Connectionclosed;transferaborted.<br>450未执行请求的文件操作。文件不可用（例如，文件繁忙）。<br>451请求的操作异常终止：正在处理本地错误。<br>452未执行请求的操作。系统存储空间不够。<br>5xx-永久性否定的完成答复<br>该命令不成功，错误是永久性的。如果客户端重试命令，将再次出现同样的错误。500语法错误，命令无法识别。这可能包括诸如命令行太长之类的错误。<br>501在参数中有语法错误。<br>502未执行命令。<br>503错误的命令序列。<br>504未执行该参数的命令。<br>530未登录。<br>532存储文件需要帐户。<br>550未执行请求的操作。文件不可用（例如，未找到文件，没有访问权限）。<br>551请求的操作异常终止：未知的页面类型。<br>552请求的文件操作异常终止：超出存储分配（对于当前目录或数据集）。<br>553未执行请求的操作。不允许的文件名。<br>常见的FTP状态代码及其原因<br>150-FTP使用两个端口：21用于发送命令，20用于发送数据。状态代码150表示服务器准备在端口20上打开新连接，发送一些数据。<br>226-命令在端口20上打开数据连接以执行操作，如传输文件。该操作成功完成，数据连接已关闭。<br>230-客户端发送正确的密码后，显示该状态代码。它表示用户已成功登录。<br>331-客户端发送用户名后，显示该状态代码。无论所提供的用户名是否为系统中的有效帐户，都将显示该状态代码。<br>426-命令打开数据连接以执行操作，但该操作已被取消，数据连接已关闭。<br>530-该状态代码表示用户无法登录，因为用户名和密码组合无效。如果使用某个用户帐户登录，可能键入错误的用户名或密码，也可能选择只允许匿名访问。如果使用匿名帐户登录，IIS的配置可能拒绝匿名访问。<br>550-命令未被执行，因为指定的文件不可用。例如，要GET的文件并不存在，或试图将文件PUT到您没有写入权限的目录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;XMLHttpRequest.status:&lt;/p&gt;
&lt;p&gt;1xx-信息提示&lt;br&gt;这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx响应。&lt;br&gt;100-继续。&lt;br&gt;101-切换协议。&lt;br&gt;
    
    </summary>
    
      <category term="-http协议" scheme="http://liting.wang/categories/http%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="-服务端、前端开发" scheme="http://liting.wang/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
